/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/': {
    /** a pure-JSON endpoint for packing requests. */
    post: {
      parameters: {
        body: {
          /** complete set of items, boxes, and parameters to pack. */
          pack?: definitions['Pack']
        }
      }
      responses: {
        /** Successful pack. */
        200: {
          schema: {
            /** @description List of boxes, packed, with their contained items. */
            boxes?: {
              box?: definitions['Box']
            }[]
            /** @description title of packing result, when applicable. */
            title?: string
            /** @description build timestamp of engine. */
            built?: string
            /** @description start timestamp of pack. */
            startedAt?: string
            /** @description version of engine */
            version?: string
            /** @description cardinality of all packed boxes */
            lenBoxes?: number
            /** @description total sum of quantities of all items */
            lenItems?: number
            /** @description cardinality of distinct units of items (count of cases, eaches, etc.) */
            lenUnits?: number
            /** @description cardinality of items unabled to be packed */
            lenLeftovers?: number
            /** @description total estimated cost of all packed boxes, when applicable, in cents. */
            totalCost?: number
            /** @description total volume of all boxes returned */
            totalVolume?: number
            /** @description total net (item) volume of all packed (non-leftover) items */
            totalVolumeNet?: number
            /** @description total net volume plus reserved volume from "reservedSpace" */
            totalVolumeUsed?: number
            /** @description totalVolumeUsed divided by totalVolume */
            totalVolumeUtilization?: number
            /** @description total gross weight of all packed boxes, including box tare weights and item weights. */
            totalWeight?: number
            /** @description seconds spent in packing */
            packTime?: number
            /** @description seconds spent in rendering and placement instruction creation of packing solution */
            renderTime?: number
            /** @description seconds spent generating response, total. */
            totalTime?: number
            /** @description items left over that could not be packed into any available boxes. */
            leftovers?: definitions['Item'][]
            /** @description name of item sort algorithm used. */
            itemSortUsed?: string
            /** @description whether the item sort was reversed. */
            itemSortReverseUsed?: boolean
            /** @description name of box type choice goal used. */
            boxTypeChoiceGoalUsed?: string
            /** @description additional javascripts for any image loading. */
            scripts?: string
            /** @description additional styles for pack images */
            styles?: string
            /** @description all box SVG images */
            svgs?: string[]
            /** @description a client-provided string identifier for the order this pack corresponds to. */
            orderId?: string
            /** @description a client-provided string identifier for the pack request being made. */
            requestId?: string
            /** @description if PNG imageFormat selected, list of PNG image objects. */
            images?: definitions['Image'][]
            /** @description stem of authorization key used, if any. */
            usedKeyStem?: string
            /** @description any warning messages about non-critical issues arising during the pack. */
            warnings?: string[]
            /** @description a fingerprint corresponding to the request content for identification within Paccurate Manager. */
            requestFingerprint?: string
            /** @description a fingerprint corresponding to the response content for identification within Paccurate Manager */
            responseFingerprint?: string
            /** @description a unique identifier for this pack transaction, which can be used to directly retrieve the pack via the Paccurate Manager. */
            packUuid?: string
          }
        }
        /** Bad request. Malformed or some other problem occurred processing the request. */
        400: {
          schema: definitions['Error']
        }
        /** Invalid input. The request was well-formed, but the parameters were contradictory, invalid, or otherwise somehow unable to be processed. More information will be contained in the error details. */
        422: {
          schema: definitions['Error']
        }
        /** Rate limited. Without an API key, only 10 unique requests are allowed per day for testing or demonstration purposes. Note that a randomized pack repeated is only a single unique request. */
        429: {
          schema: definitions['Error']
        }
        /** Unexpected error. */
        500: {
          schema: definitions['Error']
        }
      }
    }
  }
}

export interface definitions {
  Error: {
    message: string
    details?: string
    code: number
  }
  Pack: {
    /** @description a client-provided string identifier for the pack request being made. */
    requestId?: string
    /** @description a client-provided string identifier for the order this pack corresponds to. */
    orderId?: string
    /**
     * @description aligns all items laying flat. If possible, it may create a "brick-laying" pattern to increase stability.
     * @default false
     */
    layFlat?: boolean
    /**
     * @description alternates layFlat orientation by layer, so as to create an interlocked placement pattern and improve item stability.
     * @default false
     */
    interlock?: boolean
    /**
     * @description only pack items at valid corner points of other items (optimal)
     * @default true
     */
    corners?: boolean
    /**
     * @description item set definitions if not creating random items.
     * @example [
     *   {
     *     "refId": 0,
     *     "color": "tomato",
     *     "dimensions": {
     *       "x": 4.2,
     *       "y": 7,
     *       "z": 8
     *     },
     *     "weight": 4.5,
     *     "quantity": 10
     *   },
     *   {
     *     "refId": 1,
     *     "color": "cornflowerblue",
     *     "dimensions": {
     *       "x": 3,
     *       "y": 3,
     *       "z": 5
     *     },
     *     "weight": 2,
     *     "quantity": 13
     *   }
     * ]
     */
    itemSets?: definitions['ItemSet'][]
    /** @description box type definitions for packing, will override boxTypeSets defined. */
    boxTypes?: definitions['BoxType'][]
    /** @description list of dynamic boxTypeGenerators to use, in combination with boxTypes */
    boxTypeGenerators?: definitions['BoxTypeGenerator'][]
    /**
     * @description default attributes for all "boxTypes", to be overridden by any individual "boxType" attributes specified.
     * @example {
     *   "weightMax": 50,
     *   "rateTable": {
     *     "dimFactor": 166
     *   }
     * }
     */
    boxTypeDefaults?: definitions['BoxProperties']
    /**
     * @description pre-packed boxes, including any items specified that will be packed and excess space used before any new boxes are created.
     * @example []
     */
    boxes?: definitions['Box'][]
    /**
     * @description an estimate of typical box utilization for the quick "estimated" boxTypeChoiceStyle, which will be used to ensure "estimated" box type choices are not overly optimistic regarding potential volume utilization.
     * @default 0.85
     * @example 0.85
     */
    usableSpace?: number
    /**
     * @description space in boxes that is reserved, i.e., for packing material.
     * @default 0
     * @example 0.2
     */
    reservedSpace?: number
    /**
     * @description predefined box types to be used, separated by commas. Will be overridden by boxTypes. Acceptable values are <ul><li>"fedex"--FedEx OneRate</li><li>"usps"--USPS Priority Flat Rate</li><li>"pallet"--full-, half-, and quarter-sized 48"x40" pallets.
     * @example []
     */
    boxTypeSets?: definitions['BoxTypeSet'][]
    /**
     * @description The x,y,z coordinates of the virtual eye looking at the package for visualization purposes. Default is isometric, "1,1,1". To generate a side view, one could use "0.001,1.0,0.001".
     * @example {
     *   "x": 1,
     *   "y": 1,
     *   "z": 1
     * }
     */
    eye?: definitions['Point']
    /**
     * @description the x,y,z coordinates of an optional packing origin. A packing origin is used to create more balanced packing for situations where load needs to be considered. E.g., for a 40"x48" pallet, a packOrigin representing the middle of the pallet, "0,20,24", would cause placement to minimize the distance of the packed items from the center of the pallet.
     * @example {
     *   "x": 0,
     *   "y": 0,
     *   "z": 0
     * }
     */
    packOrigin?: definitions['Point']
    /**
     * @description <b>[deprecated]</b> the shipping zone in order to use basic zone-based price optimization.
     * @example null
     */
    zone?: number
    /**
     * @description Array of packing rules.
     * @example []
     */
    rules?: definitions['Rule'][]
    /**
     * @description create random items
     * @default false
     */
    random?: boolean
    /**
     * @description number of random items to generate and the quantity of each if "random" is set to true. a value of 5 would create 5 different items with a quantity of 5 each, making the total item quantity equal to n&sup2;
     * @default 5
     */
    n?: number
    /**
     * @description maximum item dimension along a single axis for randomly generated items.
     * @default 10
     */
    randomMaxDimension?: number
    /**
     * @description maximum item weight for randomly generated items.
     * @default 10
     */
    randomMaxWeight?: number
    /** @description maximum quantity for randomly generated items. */
    randomMaxQuantity?: number
    /**
     * @description if random is selected, seed the random number generator to deterministically generate random items to pack.
     * @default true
     * @example false
     */
    seed?: boolean
    /**
     * @description if seed is set to true, specifies a non-default seed for the random number generator.
     * @default 1
     */
    seedValue?: number
    /**
     * @description width of rendered SVGs in pixels.
     * @default 400
     */
    imgSize?: number
    /**
     * @description template name for markup generation.
     * @example
     * @enum {string}
     */
    template?: 'demo.tmpl' | 'shipapp.tmpl' | 'boat.tmpl'
    /**
     * @description include inline javascripts and styles for base template
     * @default false
     * @example false
     */
    includeScripts?: boolean
    /**
     * @description include inline images, default is always on
     * @default true
     * @example true
     */
    includeImages?: boolean
    /**
     * @description case-insensitive format to render images in, either 'SVG' or 'PNG', if includeImages is enabled.
     * @default svg
     * @enum {string}
     */
    imageFormat?: 'svg' | 'png'
    /**
     * @description If placementStyle is set to "default", coordOrder sets the placement priority of axes ascendingly. "0,1,2" would search for placement points along the Z(length,"2"), then Y(width,"1"), and finally X(height"0"). Keep in mind that in the default rendering the "up" direction is X and the other axes follow the right-hand rule.
     * This is useful for different packing methods. E.g., Utilizing "2,0,1" would pack a shipping container first in the Y(width) direction, then in the X(height) direction, and finally in the Z(length) direction, replication a floor-to-ceiling, front-to-back loading method.
     * @example [
     *   0,
     *   1,
     *   2
     * ]
     */
    coordOrder?: number[]
    /**
     * @description if selected, will ensure that all like items will be packed together, in no more than [cohortMax] different groups within a single container.
     * @default false
     */
    cohortPacking?: boolean
    /**
     * @description the maximum number of contiguous cohorts for a given item type within a single container. E.g., if you pack 40 chairs in a single container, a cohortMax of 2 could yield one (all 40 chairs in a single block if space is availabe) or two (say, 25 chairs in one corner and 15 in the other) contiguous cohorts.
     * @default 2
     */
    cohortMax?: number
    /**
     * @description The amount an item can overhang lower items that it is placed upon. The units are whatever units the box and item dimensions are given in. By convention, inches.
     * @default -1
     */
    allowableOverhang?: number
    /**
     * @description How to place items. 'default' will defer to coordOrder, 'corner' minimizes distance to rear, bottom corner, 'wedge' minimizes distance to middle of bottom, back edge, 'mound' minimizes distance to center of carton bottom.
     * @default default
     * @enum {string}
     */
    placementStyle?: 'default' | 'corner' | 'wedge' | 'mound' | 'orb'
    /**
     * @description Method to use to sort items for placement. Default is item volume descending. 'largest-box-needed' is by the volume of the smallest box type specified that will fit the item, descending, 'largest-girth' is 2*(width + height), descending, 'longest-dimension' is by longest single item dimension, descending, 'shortest-dimension' is by shortest single dimension, ascending, 'largest-cross-section' is by largest product of the two greatest dimensions, descending, 'set-volume' is by total 'itemSet' volume, descending. 'weight' is by weight, descending. 'density' is by item weight per unit volume, descending. It can often be worth attempting packs with competing itemSorts and picking the lowest cost option. 'all' uses all available item sorts, whereas 'combined' uses a recommended set of item sorts, both returning the lowest 'totalCost' option.
     * @default combined
     * @enum {string}
     */
    itemSort?:
      | 'default'
      | 'largest-box-needed'
      | 'largest-girth'
      | 'largest-length-plus-girth'
      | 'longest-dimension'
      | 'shortest-dimension'
      | 'largest-cross-section'
      | 'set-volume'
      | 'density'
      | 'weight'
      | 'combined'
      | 'all'
    /**
     * @description Whether or not to reverse the itemSort utilized.
     * @default false
     */
    itemSortReverse?: boolean
    /**
     * @description Whether or not to use both normal and reversed itemSorts.
     * @default false
     */
    itemSortDualDirection?: boolean
    /**
     * @description For all items where orientation flipping is used, the orientation producing the highest multiple of items fit per remaining dimension is used as the first orientation. This option should be enabled when packing high quantities of single item types, but may produce inconsistent results in other cases. Defers to item orientation locking and itemOrientationSearchDepth > 0 if a superior result is found.
     * @default false
     */
    itemInitialOrientationBestForBox?: boolean
    /**
     * @description Whether to attempt packing by either greedily placing items or placing all allowable combinations of initial item orientations and selecting the most performant. When true, items will be placed immediately using the orientation reflected by their dimensions definition and will only be flipped if a placement cannot be found and the item rules allow orientation changes. When false, all allowable initial orientation combinations will be attempted for each item in each box.
     * @default true
     */
    itemInitialOrientationPreferred?: boolean
    /**
     * @description When itemInitialOrientationPreferred is set to false, the itemOrientationSearchDepth is the number of unique, sorted, groups of Items sharing the same ItemSet definition that will be have every combination of initial orientation attempted. A value of 1 signifies that only the first item (and others still unpacked from its ItemSet) will have every orientation attempted and the engine subsequently selecting the most performant. A value of 2 signifies that the first groups of unpacked items, each sharing an ItemSet, will have every combination of orientation attempted. Increasing this value from 1 can very rapidly result in excessive complexity and a timeout error instead of a result, so discretion is advised.
     * @default 1
     */
    itemOrientationSearchDepth?: number
    /**
     * @description Whether or not the items should be initially sorted by their sequence value instead of by the specified itemSort. This is not always useful, as the default "biggest-first" volume sort is very effective for items, and constraining by maxSequenceDistance is applied regardless of this field. That said, for doing custom pre-sorts such as weight-based instead of volume based, this value should be set to true.
     * @default false
     */
    sequenceSort?: boolean
    /**
     * @description Colorize items solely by their sequence value, light when sequence is high, dark when it is low. Useful for indicating item bin location, weight, or other sequence property that may not be apparent from the default visualization.
     * @default false
     */
    sequenceHeatMap?: boolean
    /** @description This is the maximum distance allowable between two sequence values of items packed in a common box. E.g., "Distance" for an item sequence composed of aisle/bin combinations of "0401" and "1228" has a sequence distance of \|1228 - 401\| = 827 */
    maxSequenceDistance?: number
    /**
     * @description Defines how available boxTypes are selected when a new box must be created to pack additional items. The 'estimated' style uses 'usableSpace' to estimate how quickly each valid boxType will be filled by both weight and volume, and estimated cost is calculated. 'actual' attempts real placement of subsequent items in each available boxType and selects the one with the lowest actual cost. 'actual' is much slower than 'estimated', but will often return superior cost optimizations.
     * @default actual
     * @enum {string}
     */
    boxTypeChoiceStyle?: 'actual' | 'estimated'
    /**
     * @description <p>When selecting the next available boxType, we must consider how far to look ahead.</p><p>Consider we have 8 items of identical dimensions, and two flat rate boxTypes. It is found that Box A can fit 6 items, and costs $12. Box B can fit 4 items, and costs $10.</p><p>If we consider only the next box, i.e., 'boxTypeChoiceLookahead' set to 0, we would select Box A. It costs $2 per item, whereas Box B is $2.50 per item. Box A is opened, 6 items are placed inside, and now 2 remain. To pack the last 2, Box B would be selected, as 2 items for $10 is $5 per item, and Box A's $12 is $6 per item.</p><p>Alternatively, if 'boxTypeChoiceLookahead' is set to 1, the boxType that provides the lowest cost per item <i>including</i> the lookahead boxType(s) would be selected. In this case, we find we need 2 of Box B, for $20 total, to fit all 8 items, or $2.50 per item, and would need 1 of Box A and 1 of Box B if Box A is selected first, for $22 total or $2.75 per item. Box B would be used.</p><p>Please note that 'boxTypeChoiceLookahead', especially when combined with the 'actual' 'boxTypeChoiceStyle' can have significant performance impacts. 0 is recommended for real-time use cases.</p>
     * @default 0
     */
    boxTypeChoiceLookahead?: number
    /**
     * @description Control the ability for partially-filled boxes to allow packing of later-sorted items. A value of null or -1 means unlimited lookback is permitted, i.e., every box can be used to pack any allowable item that fits regardless of its pack sequence, and all boxes will remain "opened" or available for packing until the last item in the pack sequence is attempted. A value of 0 means lookback is not allowed, and as soon as the next item in the pack sequence does not fit into a partially filled box, that box is "closed" or locked and will not permit any additional items (i.e., out-of-sequence items) to be packed in it.
     * @default -1
     */
    boxTypeChoiceLookback?: number
    /**
     * @description The objective to evaluate boxTypeChoices by. 'lowest-cost' minimizes price or volume cost of boxTypes selected, 'most-items' maximizes item count per box opened, i.e., fewest total boxes used.
     * @default lowest-cost
     * @enum {string}
     */
    boxTypeChoiceGoal?: 'lowest-cost' | 'most-items'
    /**
     * @description The maximum number of boxes to be used to pack the items in the request, potentially leaving items in 'leftovers' if there is insufficient space, determined by item 'sequence' or selected 'itemSort'. If existing 'boxes' are passed to the pack request, they count towards this total, but will not be excluded, allowing for situations where 'lenBoxes' may be greater than 'boxesMax'. However, no 'boxTypes' will be used to create additional boxes unless doing so would not exceed 'boxesMax'.
     * @default 0
     */
    boxesMax?: number
    /**
     * @description The maximum number of boxes that a single ItemSet's member items (i.e., all that share the same refId) can be spread across. Any items that do not fit within this number of boxes will be precluded from packing and returned in the leftovers array. The default setting of 0, a negative number, and null are all equivalent and indicate no maximum limit.
     * @default 0
     */
    boxesPerItemSetMax?: number
    /**
     * @description The maximum number of boxes that a single non-empty sequence's member items (i.e., all that share the same non-empty sequence) can be spread across. Any items that do not fit within this number of boxes will be precluded from packing and returned in the leftovers array. The default setting of 0, a negative number, and null are all equivalent and indicate no maximum limit.
     * @default 0
     */
    boxesPerSequenceMax?: number
    /**
     * @description The maximum quantity of discrete items that a single box can contain. The default setting of 0, a negative number, and null are all equivalent and indicate no maximum limit, optionally overridden by 'boxType' settings.
     * @default 0
     */
    itemsPerBoxMax?: number
    /**
     * @description The maximum quantity of unique 'item.refId' values that a single box can contain. The default setting of 0, a negative number, and null are all equivalent and indicate no maximum limit, optionally overridden by 'boxType' settings.
     * @default 0
     */
    itemSetsPerBoxMax?: number
    /**
     * @description Limit the item count that can share a placement on a specific line parallel to the placement axis, e.g., '[1,2,1]' means items can be placed 1 high, 2 wide, and 1 deep within the box. A value of '0' is equivalent to no limit along that axis. Overridden by 'boxType' settings.
     * @example [
     *   1,
     *   2,
     *   1
     * ]
     */
    itemsInlineMax?: number[]
    /**
     * @description The maximum number of generated box sizes to randomly sampled when generating box types. Default of 0 is unlimited, and in some cases may never return without a limit. `64` is a sensible value.
     * @default 0
     * @example 64
     */
    generatedBoxTypesMax?: number
    /**
     * @description The tiebreaker to use in the event to box type choices are otherwise completely equal. Default is "volume", alternative is "weight".
     * @default volume
     * @enum {string}
     */
    valueTiebreaker?: 'volume' | 'weight'
    /**
     * @description Optional timeout for request computation, will be reduced to endpoint maximum if in excess of published timeout.
     * @example 30
     */
    timeout?: number
  }
  BoxProperties: {
    /** @description name for the type of box. */
    name?: string
    /** @description box type reference identifier passed backed from request. */
    refId?: number
    /** @description Fixed price of the container, in whole units of currency, default USD cents. This can represent the cost of a flat rate carton, the cost of the actual carton materials, or it can include any other flat fees that may need to be added on a <i>per-carton</i> basis, such as handling, accessorial surchages, oversize fees, etc. This value is <i>added</i> to any rate table rates defined for the carton. */
    price?: number
    /**
     * @description weight of the container when empty or otherwise unladen, i.e., of the box itself.
     * @default 0
     */
    weightTare?: number
    /** @description maximum allowable gross weight for the box, i.e., all packed item weights plus the weightTare. */
    weightMax: number
    /** @description the [height,length,width] of the box. */
    dimensions: definitions['Point']
    /** @description if required, data describing the outer dimensions of the box. */
    outer?: {
      /** @description on return, if an outer `dimensionChange` was specified, the final dimensions of the box. */
      dimensions?: definitions['Point']
      /** @description Outers must be specified as the difference of each dimension from the inner dimensions. E.g., an inner `x` of `10` with an outer `dimensionChange.x` of `0.25` would result in an `outer.dimensions.x` of `10.25`. Outers are only used for informational purposes, and for `pack-sequence` rule operations when using the `boxes-to-items` `reduce` method (to add outer dimensions to inner boxes when they are packed in later steps.) */
      dimensionChange?: definitions['Point']
    }
    /** @description the coordinates of the center of mass of the box. */
    centerOfMass?: definitions['Point']
    /**
     * @description space in boxes that is reserved, i.e., for packing material, overriding top-level 'reservedSpace'.
     * @default 0
     * @example 0.2
     */
    reservedSpace?: number
    /**
     * @description The maximum quantity of discrete items that a single box can contain. The default setting of 0, a negative number, and null are all equivalent and indicate no maximum limit, overriding top-level 'itemsPerBoxMax'.
     * @default 0
     */
    itemsPerBoxMax?: number
    /**
     * @description The maximum quantity of unique 'item.refId' values that a single box can contain. The default setting of 0, a negative number, and null are all equivalent and indicate no maximum limit, overriding top-level 'itemSetsPerBoxMax' settings.
     * @default 0
     */
    itemSetsPerBoxMax?: number
    /**
     * @description Limit the item count that can share a placement on a specific line parallel to the placement axis, e.g., '[1,2,1]' means items can be placed 1 high, 2 wide, and 1 deep within the box. A value of '0' is equivalent to no limit along that axis.
     * @example [
     *   1,
     *   2,
     *   1
     * ]
     */
    itemsInlineMax?: number[]
    /** @description An optional rate table definition for improved carton selection and pricing optimization. Defaults are included using retail rates for FedEx and UPS if carrier and service is provided, but optimization can be improved with more data passed in a carton's specific rate table. Methods are <ol><li>Provide carrier, service, and zone.</li><li>Provide all acceptable weights and prices to use for the carton, similar to actual carrier rate tables.</li><li>Provide the coefficients required for a simple linear weight-dependent pricing model.</li></ol> */
    rateTable?: definitions['RateTable']
    /** @description In order to add arbitrary constraints for certain items based not upon weight or physical dimensions, a `propertyConstraint` can be added here for each additional numerical constraint desired. E.g., limiting the weight of a restricted component of an item to 5 lbs per box, while still allowing total item weight of, e.g., 50 lbs per box. All numeric properties are treated as unit amounts and summed individually (not at the `ItemSet` level). */
    propertyConstraints?: {
      /** @description the string matching the item `properties` key to search for. */
      key?: string
      /** @description the maximum allowable value for the member items with this property. */
      max?: number
      /**
       * @description sum is the only supported aggregate function at present
       * @default sum
       */
      aggregate?: string
      /**
       * @description the value of the constrained item property within this box. to set an initial value, include it in your `boxType` definition.
       * @default 0
       */
      value?: number
    }[]
  }
  /**
   * @description box types to be used for packing.
   * @example {
   *   "name": "Example Box",
   *   "dimensions": {
   *     "x": 7.5,
   *     "y": 12,
   *     "z": 16
   *   },
   *   "weightMax": 60,
   *   "weightTare": 0.5,
   *   "price": 125
   * }
   */
  BoxType: definitions['BoxProperties']
  /**
   * @description box type sets for useful defaults.
   * @enum {string}
   */
  BoxTypeSet: 'usps' | 'fedex' | 'pallet' | 'customer'
  /** @description A generator of box types, specifying bounds of acceptable box types and defining dynamic cost characteristics. */
  BoxTypeGenerator: {
    /** @description default attributes for all generated "boxTypes" */
    boxTypeDefaults?: definitions['BoxProperties']
    /**
     * @description Type of generator to use. "cartesian" requires axis list and range "options" fields in order to discover acceptable carton sizes, whereas "pack-as-is" generates a box for each item (optionally selected by an itemMatch "exclude" rule to capture only items able to be shipped as is) and includes default or custom rate and pricing information on the as-is packaging to adequately weight the decision between overboxing (potentially with other items) or shipping alone. Compare with the "pack-as-is" rule, which will strictly pass through an item as an output box, and will not evaluate whether to overbox. E.g., a "price" of -1 can be set in the "boxTypeDefaults" object for a "pack-as-is" generator in order to incentivize a pack-as-is versus an overbox the smallest meaningful amount.
     * @enum {string}
     */
    operation?: 'cartesian' | 'pack-as-is'
    options?: {
      /** @description list of available x-axis lengths */
      xList?: definitions['GeneratorAxisList']
      /** @description range of available x-axis lengths */
      xRange?: definitions['GeneratorAxisRange']
      /** @description list of available y-axis lengths */
      yList?: definitions['GeneratorAxisList']
      /** @description range of available y-axis lengths */
      yRange?: definitions['GeneratorAxisRange']
      /** @description list of available z-axis lengths */
      zList?: definitions['GeneratorAxisList']
      /** @description range of available z-axis lengths */
      zRange?: definitions['GeneratorAxisRange']
      /** @description list of GeneratorLimit objects defining the bounds of generated box sizes. */
      limits?: definitions['GeneratorLimit'][]
      /** @description list of GeneratorPriceComponents defining the dynamic price behaviors of generated box sizes. */
      priceComponents?: definitions['GeneratorPriceComponent'][]
      /** @description if unset or false, the generator will reduce its dimensions to the maximum of the max extent of items placed within it or the minimum specified limit along each axis containint a GeneratorAxisRange object; if true, the generator will not reduce its dimensions along any axis; trimming to max extent is ignored on all axes with only GeneratorAxisList objects, as to respect specified box footprints. By default, rounds up trimmed dimensions to the nearest tenths unit of length. */
      noTrimToMaxExtent?: unknown
    }
  }
  /** @description enumerated list of possible lengths for given axis. */
  GeneratorAxisList: number[]
  /** @description configurable range of possible lengths for given axis. */
  GeneratorAxisRange: {
    /** @description the minimum possible axis length to generate */
    min?: number
    /** @description the maximum possible axis length to generate */
    max?: number
    /**
     * @description if true, intelligently select possible axis lengths based upon item dimensions.
     * @default false
     */
    deriveFromItems?: boolean
    /**
     * @description if true, select axis length based upon first item placed in each generated box, overriding deriveFromItems and increment.
     * @default false
     */
    fitForFirstItem?: boolean
    /** @description if `deriveFromItems` is not true, the desired increment for box dimension rounding. E.g., `0.25` for a box in inches would round up to the quarter inch. `10` would round to the next even 10s digit. Note that `min` and `max` are included as is, and are not rounded to the nearest `increment`. So, `min 5, max 59, increment 10` could produce any of `[5,10,20,30,40,50,59]` for this `GeneratorAxisRange`. Also note that small `increment` values would benefit from a `generatedBoxTypesMax` set. */
    increment?: number
  }
  /** @description a generator limit for a given calculated box size metric. */
  GeneratorLimit: {
    metric?: definitions['Metric']
    /** @description minimum allowable value of calculated metric */
    min?: number
    /** @description maximum allowable value of calculated metric */
    max?: number
  }
  /** @description a dynamic price component determining the generated box price property to set. */
  GeneratorPriceComponent: {
    /** @description key for a given price component, allowing for multiple metrics to calculate the same value, in which case the maximum price will be selected. */
    key?: string
    metric?: definitions['Metric']
    /**
     * @description how to aggregate `priceComponents` with common `key` values. `max` selects the largest threshold price across all `priceComponents` sharing a `key`. `product` takes the last (i.e., highest) matching threshold price from each `priceComponent` sharing a `key` and multiplies them together. `sum` simply sums all prices from all matching thresholds across all `priceComponents` sharing the same key. NB all `priceComponents` sharing a `key` must share the same `aggregator` to have predictable behavior.
     * @default max
     * @enum {string}
     */
    aggregator?: 'max' | 'product' | 'sum'
    /** @description list of number thresholds of corresponding metric above which corresponding prices are triggered. Note that thresholds are traversed in reverse in cases where order matters (e.g., when using the `product` aggregator) */
    thresholds?: number[]
    /** @description list of integer price values to assign when corresponding thresholds are exceeded */
    prices?: number[]
  }
  /**
   * @description A named calculation for a specific value derived from a cuboid (e.g., an item or a box)
   * @enum {string}
   */
  Metric:
    | 'volume'
    | 'surface-area'
    | 'surface-area-rsc'
    | 'longest-dimension'
    | 'middle-dimension'
    | 'shortest-dimension'
    | 'length-plus-girth'
    | 'girth'
    | 'x-dimension'
    | 'y-dimension'
    | 'z-dimension'
  /** @description A completed, packed box. */
  Box: definitions['BoxProperties'] & {
    id?: number
    subspace?: definitions['Subspace']
    boxType?: definitions['BoxType']
    /** items */
    items?: {
      item?: definitions['Item']
    }[]
    /** @description total volume of the box. */
    volumeMax?: number
    /** @description utilized volume of the box, i.e., item volume plus reserved volume. */
    volumeUsed?: number
    /** @description volume of box utilized solely by packed items. */
    volumeNet?: number
    /** @description remaining volume of the box. */
    volumeRemaining?: number
    /** @description reserved volume of the box, i.e., void fill. */
    volumeReserved?: number
    /** @description percentage of volume utilized by packed items. */
    volumeUtilization?: number
    /** @description utilized weight of the box. */
    weightUsed?: number
    /** @description total weight of box's contents, not including the box's empty (tare) weight. */
    weightNet?: number
    /** @description remaining weight of the box. */
    weightRemaining?: number
    /** @description percentage of weight utilized by packed items. */
    weightUtilization?: number
    /** @description the calculated dimensional weight of this box, if applicable. */
    dimensionalWeight?: number
    /** @description whether or not dimensional weight was used for this box. */
    dimensionalWeightUsed?: boolean
    /** @description cardinality of all non-virtual items packed in this box and in any dependent subspaces it contains */
    lenItems?: number
    /** @description cardinality of distinct units of items (count of cases, eaches, etc.) */
    lenUnits?: number
    /** @description raw svg of visualization. */
    svg?: string
    /** @description string representation of box center of mass. */
    centerOfMassString?: string
    /** @description <p>sorted list of 'item.index' values representing the ordering utilized by the render, back to front.</p><p>This list works in tandem with the 'eye' point, and can represent a potentially feasible real-world packing order.</p><p>E.g., if the 'eye' is set to '{x:1, y:0, z:0}', then the packing image will show a top-down view of the carton, and 'depthOrder' will contain the order to place items so that all items on the bottom of the carton are packed first, then those in the next layer, etc., so that no item is placed beneath another already placed item.</p><p>Conversely, if the 'eye' is set to '{x:0, y:0, z:1}', the packing image will show an end-on view--as if from the doors of a shipping trailer, and 'depthOrder' will contain the order to place items so that all items farthest from the doors are placed before items directly in front of them.</p> */
    depthOrder?: number[]
    /** @description string representation of depth ordering. */
    depthOrderString?: string
  }
  /** @description general properties of an item */
  ItemProperties: {
    /** @description item type reference identifier passed backed from request, where a value of -1 or null will be auto-assigned to a unique identifier by distinct item or itemSet. */
    refId?: number
    /** @description name or description of item for your reference. */
    name?: string
    /** @description designated color name or hex code (including leading "#") for the item in pack visualizations. If 'imageFormat' is set to 'PNG', the color must be a 3-byte (i.e., 6-character) case insensitive hex code plus the leading "#", e.g., "#00ffff". */
    color?: string
    /** @description weight of this single packed item. */
    weight: number
    /** @description A sequence value for the item. This is intended for aisle-bin locations, e.g., aisle 11 bin 20 can be '1120'. Combined with maxSequenceDistance, you can restrict cartons to only have contents from within a certain range. This is very helpful for cartonization when picking efficiency is paramount. Sequence can also be used to pre-sort items for efficient packing on any arbitrary number, such as item weight instead of the default item volume. */
    sequence?: string
    /** @description the length, width, and height of the item. */
    dimensions: definitions['Point']
    /** @description the coordinates of the center of mass of the item. */
    centerOfMass?: definitions['Point']
    /**
     * @description whether or not this is a real item or a virtual, blocking space (from a subspace or loading rules)
     * @default false
     */
    virtual?: boolean
    /**
     * @description Additional properties to track per unit, which are all returned in the response.  Numerical properties can be used in conjunction with box type `propertyConstraints` to control packing (very much akin to weight constraints).
     * E.g., an item property on a Faberge egg of `"priceless-egg-quantity": 1` with a matching constraint of `"key": "priceless-egg-quantity", "max": 2, "aggregate": "sum"` would limit to 2 Faberge eggs per box.
     * Another box constraint with `"key": "priceless-egg-quantity", "max": 0` instead would effectively prohibit any items with that quantity from packing in it, similar to an exclude rule.
     * Conversely, each egg could have its own insurance amount, and there may be a maximum allowable amount per box, such as `"priceless-egg-value": 33000000` for one and `"priceless-egg-value": 22000000` for a second (for $55 million total) with a corresponding constraint of `"key": "priceless-egg-value", "max": 50000000` would prevent both eggs from being placed in one box, as $55 million exceeds the $50 million constraint on a single box (and they would be placed in their own boxes insured for $33 million and $22 million respectively
     * @example {
     *   "included-ice-lbs": 0.5,
     *   "restricted-qty": 0.1,
     *   "item-line-id": "1234-59581ABC-CAFE1909",
     *   "wms-fields": {
     *     "InternalItemID": 1398401,
     *     "SKU": 49831,
     *     "Location": "40-8012",
     *     "Kit": false,
     *     "OtherGenericProperties": "will be passed through and returned on the item."
     *   }
     * }
     */
    properties?: { [key: string]: unknown }
  }
  /** @description a specific, packed item. */
  Item: definitions['ItemProperties'] & {
    /** @description the sequence at which the item was packed. */
    index?: number
    /** @description any relevant information or warnings about the packing of the item. */
    message?: string
    /** @description the [x,y,z] placement point of the back-bottom corner of the item. */
    origin?: definitions['Point']
    /** @description the change in the estimated final cost of the box caused by adding the item. */
    deltaCost?: number
    /** @description a combination of the item's refId and its packing sequence, uniquely identifying it. */
    uniqueId?: string
    /** @description if specified, the uniqueId of the group-pack parent item this item belongs to. */
    groupPackParent?: string
    /**
     * @description quantity of basis item, i.e., eaches, this item represents, if dimensionSets were used with variable quantity contents.
     * @default 1
     */
    quantity?: number
    /** @description unit of measure, if specified. not defined or null if none. */
    unitOfMeasure?: string
    /** @description the "dimensionSet" used for this specific item object. */
    dimensionSet?: definitions['DimensionSet']
  }
  /** @description set of items sharing a common type. */
  ItemSet: definitions['ItemProperties'] & {
    /** @description quantity of items of this type in this item set */
    quantity?: number
    /** @description Alternate list of dimensions for automatic conversion of items into larger units of measure (optional). The first element is assumed to be "each", and will use the base "dimensions" and "weight" if none is provided. Additional units of measure are preferentially selected in reverse, from the last dimensionSet to the first. If the "quantityDivisor" value is less than the quantity of the itemSet, then the weight and dimensions are either automatically multiplied (with "axisMultipliers") or explicitly set with "dimensions" and "weight". The remaining item "quantity" is reduced by "quantityDivisor" as many times as possible, with remainders being filled by subordinate units of measure, with eaches being preserved last. Units are counted towards "lenUnits", whereas total item quantity counts towards "lenItems". NB, "alternate-dimensions" and "group-pack" should not be used with "dimensionSets" as they may cause unexpected results. */
    dimensionSets?: definitions['DimensionSet'][]
  } & {
    quantity: unknown
  }
  /**
   * DimensionSet
   * @description A set of dimensions for a specific item unit of measure, to be assembled in an ordered, hierarchical list of DimensionSets, each representing a whole quantity of the item. Use "dimensions", "weight", and "quantityDivisor" properties when measurements are known (e.g., 8-count case outer "dimensions" with "weight" including the empty case weight, with 8 as the "quantityDivisor"), or "axisMultipliers" when trying to pack in known multiples of the base item dimensions (or when it is unknown), e.g., a 6-pack of soda would be `"axisMultipliers":{"x":1,"y":2,"z":3}` for a 1-high by 2-wide by 3-long arrangement. All dimension sets will be used if sufficient quantities exist without regard for available container size or rules, e.g., do not pass "pallet" for a small parcel shipment.
   */
  DimensionSet: {
    /** @description Dimensions of the item in this configuration */
    dimensions?: definitions['Point']
    /** @description Multiples in x, y, and z directions of the item in this configuration. E.g., x:1, y:2, z:3 for a 3x2 6 pack of soda. If unspecified, "quantityDivisor" will default to the product of all 3 multiples. It it always relative to the basis dimensions of the item, i.e., each dimensions. */
    axisMultipliers?: definitions['Point']
    /** @description The quantity of the item contained in this configuration, i.e., in pieces or eaches. */
    quantityDivisor?: number
    /** @description The weight of the item in this configuration. If unspecified, "weight" will default to the basis item weight times "quantityDivisor". */
    weight?: number
    /** @description A string used to name or label the unit of measure. The first DimensionSet will always default to "each" unless otherwise specified. */
    unitOfMeasure?: string
  }
  /**
   * ItemMatch
   * @description Specify the items a rule applies to based upon a search substring of an itemSet property. Either 'all' must be set to true or both 'expression' and 'property' must be set.
   */
  ItemMatch: {
    /** @description if true, match this rule on all item sets specified in the request. */
    all?: boolean
    /**
     * @description the itemSet property to search with the expression.
     * @enum {string}
     */
    property?: 'sequence' | 'name'
    /** @description the query string to search the specified itemSet property for. */
    expression?: string
    /** @description query strings to search the specified itemSet property for. */
    expressions?: string[]
    /**
     * @description if true, negate substring search so rule applies only to itemSet properties not matching expression.
     * @default false
     */
    negate?: boolean
  }
  /** @description Rule definition for packing constraints. */
  Rule: {
    /** @description reference ID for the item the rule applies to. */
    itemRefId?: number
    /** @description sequence string shared by all items for the rule to apply to. */
    itemSequence?: string
    /** @description optional object defining a substring search and property to search for items the rule applies to */
    itemMatch?: definitions['ItemMatch']
    /** @description target item reference IDs that the rule applies to. */
    targetItemRefIds?: number[]
    /** @description target item sequences that the rule applies to. */
    targetItemSequences?: string[]
    /** @description target box reference IDs that the rule applies to. */
    targetBoxRefIds?: number[]
    /**
     * @description Rule type for this definition. Valid operation values include
     * <ul>
     *   <li>
     *     <h3>internal-space</h3>
     *     <p><b>itemRefId</b> contains some internal packable subspace that can be used to place subsequent <b>items</b> defined by a virtual <b>boxType</b> with an <b>origin</b> defined relative to the <b>item</b>'s <b>dimensions</b> and with an allowable <b>weightMax</b>.</p>
     *     <p>The internal subspace is subject to all rules and parameters of the parent <b>box</b> of the <b>item</b>.
     *     <p>Subspaces may nest, as in a pencil can be placed into a flower pot which may then be put inside a bucket which may then be put inside a single <b>box</b>.</p>
     *     <p>Internal space subspaces are "opened" only when an <b>item</b> with an internal space is placed into a <b>box</b>. They are then treated preferentially over opening a new <b>box</b> from the specified <b>boxTypes</b> until their weight or volume is exhausted, or no valid placements can be found within them for remaining <b>items</b>.</p>
     *     <p><b>"options"</b> contents:</p>
     *        <table>
     *          <tr><th>key</th><th>value</th><th>description</th></tr>
     *          <tr><td>type</td><td>string</td><td>identifies this internal space as being defined by a subspace.</td></tr>
     *          <tr><td>boxType</td><td>BoxType</td><td>BoxType definition, values specified are used except price and rate and unless superseded by parent BoxType attributes.</td></tr>
     *          <tr><td>origin</td><td>Point</td><td>origin of the subspace relative to Item dimensions.</td></tr>
     *          <tr><td>blocking</td><td>boolean</td><td>whether the bounding box of the internal space blocks placement of other items in the parent box.</td></tr>
     *          <tr><td>display</td><td>boolean</td><td>option to display the bounding box of the internal space as a white semi-transparent object in the visualization of its containing Item.</td></tr>
     *          <tr><td>displayChildren</td><td>boolean</td><td>option to display the children packed within the internal space in the visualization of its containing parent Box.</td></tr>
     *        </table>
     *     <pre>{
     * "operation": "internal-space",
     * "itemRefId": 0,
     * "options": {
     *   "type": "subspace",
     *   "boxType": {
     *     "weightMax": 2,
     *     "name": "flower pot interior",
     *     "price": 0,
     *     "dimensions": {
     *       "x": 1.5,
     *       "y": 1.5,
     *       "z": 1.5
     *     }
     *   },
     *   "origin": {
     *     "x": 0.25,
     *     "y": 1,
     *     "z": 1
     *   },
     *   "blocking": true,
     *   "display": true,
     *   "displayChildren": true
     * }
     * }</pre>
     *   </li>
     *
     *   <li>
     *     <h3>alternate-dimensions</h3>
     *     <p>Specify a set of alternate dimensions to attempt when packing in addition to the primary <b>dimensions</b> attribute of the <b>item</b>. Original
     *        dimensions can be replaced completely with <b>replaceOriginal</b>, typically used to apply general, label-based rules to decrease (as in folding)
     *        or increase (as in wrapping in packaging material) item dimensions in a generalized way. <b>dimensionScaleChanges</b> are candidate scale changes
     *        for each dimension, e.g., <b>"x": -0.5</b> means reduce the "x" dimension by 50% (folded in half). Whereas, <b>dimensionChanges</b> refer
     *        to static changes in any matching item dimensions, e.g., <b>"x": 1, "y": 1, "z": 1</b> means add one inch to each dimension of matching items.
     *     <p><b>"options"</b> contents:</p>
     *        <table>
     *          <tr><th>key</th><th>value</th><th>description</th></tr>
     *          <tr><td>dimensions</td><td>[]Point</td><td>A list of possible dimensions that will be attempted. Dimensions are sorted by volume ascending.</td></tr>
     *          <tr><td>dimensionChanges</td><td>[]Point</td><td>A list of dimension change vectors that are added to the matching item dimensions to yield packing dimensions </td></tr>
     *          <tr><td>dimensionScaleChanges</td><td>[]Point</td><td>A list of dimension scale-change vectors that are multiplied with the matching item dimensions, then added to the matching item dimensions to yield packing dimensions</td></tr>
     *          <tr><td>replaceOriginal</td><td>boolean</td><td>When true, the original dimensions from matching item dimensions are discarded, and only the alternate dimensions are considered.</td></tr>
     *        </table>
     *     <pre>{
     *       "operation": "alternate-dimensions",
     *       "itemRefId": 0,
     *       "options": {
     *         "dimensions": [{
     *           "x": 6,
     *           "y": 8,
     *           "z": 16
     *         },
     *         {
     *           "x": 7.5,
     *           "y": 10,
     *           "z": 10
     *         }],
     *         "dimensionChanges": [{
     *           "x": 1.0,
     *           "y": 1.5,
     *           "z": 1.0
     *         }],
     *         "dimensionScaleChanges": [{
     *           "x": -0.5,
     *           "z": 0.1
     *         },
     *         {
     *           "x": 0.1,
     *           "y": 0.1,
     *           "z": 0.1
     *         }]
     *       }
     *     }</pre>
     *   </li>
     *
     *   <li>
     *     <h3>exclude</h3>
     *     <p><b>itemRefId</b> is excluded from being packed in the same carton with all <b>targetItemRefIds</b>, or in any carton found in <b>targetBoxRefIds</b></p>
     *     <pre>{
     *   "operation": "exclude",
     *   "itemRefId": 0,
     *   "targetItemRefIds": [1,2],
     *   "targetBoxRefIds": [3]
     * }</pre>
     *
     *
     *   </li>
     *   <li>
     *     <h3>exclude-all</h3>
     *     <p><b>itemRefId</b> is excluded from being packed in the same carton with all items without its refId</p>
     *     <pre>{
     *   "operation": "exclude-all",
     *   "itemRefId": 0
     * }</pre>
     *
     *
     *   </li>
     *   <li>
     *     <h3>pack-as-is</h3>
     *     <p>Each individual item with <b>itemRefId</b> is packed in a carton matching its exact dimensions, i.e., it is assumed the item is ship-ready and bypasses being placed in a box. If you have an item quantity of 6, it will place the items in 6 boxes.</p>
     *     <pre>{
     *   "operation": "pack-as-is",
     *   "itemRefId": 0
     * }</pre>
     *
     *
     *   </li>
     *   <li>
     *     <h3>irregular</h3>
     *     <p>There is one type of irregular item packing right now, "roll".</p>
     *     <ul>
     *       <li>
     *         <h4>"roll"</h4>
     *         <p>A rolled irregular item is simply where the item dimensions X, Y, and Z, represent the thickness, width, and total
     *         length of a material meant to be rolled up (possibly on a spool, dowel, etc.) and shipped as such. Marked this way, the bounding box
     *         of the roll cylinder will be used as its shipping dimensions. E.g., a roll has a width 60 inches and a diameter of 12 inches,
     *         it will be shipped as if it were a 12" x 12" x 60" item. Rolls can have a maximum allowable diameter, and any rolls that must be
     *         split will have their weights calculated on a pro-rated basis of the total length and weight in the item contents.<p/>
     *         <p><b>"options"</b> contents:</p>
     *         <table>
     *           <tr><th>key</th><th>value</th><th>description</th></tr>
     *           <tr><td>type</td><td>"roll"</td></tr>
     *           <tr><td>innerDiameter</td><td><i>number</i></td><td>the inner diameter of any dowel or tube used that serves as the initial diameter of the roll.</td></tr>
     *           <tr><td>spoolWeight</td><td><i>number</i></td><td>the additional weight of each spool or dowel if applicable</td></tr>
     *           <tr><td>maxDiameter</td><td><i>number</i></td><td>the maximum acceptable diameter of a resultant roll.</td></tr>
     *           <tr><td>maxWeight</td><td><i>number</i></td><td>the maximum acceptable weight of a resultant roll.</td></tr>
     *           <tr><td>minRollLength</td><td><i>number</i></td><td>the minimum length above which rolling will occur. E.g., if less than 12" remain, ship it flat without rolling.</td></tr>
     *         </table>
     *       <pre>{
     *   "operation": "irregular",
     *   "itemRefId": 0,
     *   "options": {
     *     "type": "roll",
     *     "innerDiameter": 1.0,
     *     "spoolWeight": 1.0,
     *     "maxDiameter": 8.0,
     *     "maxWeight": 150,
     *     "minRollLength": 12
     *   }
     * }</pre>
     *       </li>
     *     </ul>
     *   </li>
     *   <li>
     *     <h3>lock-orientation</h3>
     *     <p><b>itemRefId</b> is locked from rotation of its original dimensions, with axes of rotation excepted by <b>freeAxes</b></p>
     *     <p><b>"options"</b> contents:</p>
     *        <table>
     *          <tr><th>key</th><th>value</th><th>description</th></tr>
     *          <tr><td>freeAxes</td><td>array</td><td>Array of axis indices to be allowed rotational freedom. E.g., [0] for only yaw allowed, [0,1] for yaw and roll.</td></tr>
     *        </table>
     *     <pre>{
     *   "operation": "lock-orientation",
     *   "itemRefId": 0,
     *   "options": {
     *     "freeAxes": [0,1]
     *   }
     * }</pre>
     *   </li>
     *   <li>
     *     <h3>fragile</h3>
     *     <p><b>itemRefId</b> gains conditions for its packing and the packing of items directly above it. Fragile items can be wrapped in a thickness of packing material that is added to each face of the item, or marked as only to be packed on top of other items, or a maximum weight can be given for all additional items supported by the fragile item, or a simple priority flag can be specified where fraile items with the highest priority are never packed underneath items with a lower or unspecified priority.<p/>
     *     <p><b>"options"</b> contents:</p>
     *     <table>
     *       <tr><th>key</th><th>value</th><th>description</th></tr>
     *       <tr><td>display</td><td><i>boolean</i></td><td>whether to display the virtual subspace created above fragile items for analysis purposes.</td></tr>
     *       <tr><td>maxWeight</td><td><i>number</i></td><td>the maximum weight of items that may be placed above this fragile item.</td></tr>
     *       <tr><td>onTopOnly</td><td><i>boolean</i></td><td>specifies that nothing will be placed between the top dimensions of this item and the top of the box or container it is packed within, overriding <b>maxWeight</b> if previously specified.</td></tr>
     *       <tr><td>excludeOverweight</td><td><i>boolean</i></td><td>automatically applies an item exclusion rule between this item and any items of a different <b>refId</b> with an item <b>weight</b> exceeding <b>maxWeight</b>.</td></tr>
     *       <tr><td>unrestrictedPlacement</td><td><i>boolean</i></td><td>when true, bypasses creation of a placement-restricting fragility subspace, above the item used in conjunction with <b>excludeOverweight</b>, <b>packingMaterialThickness</b>, or other non-placement-orientated fragility features (not compatible with <b>onTopOnly</b>.)</td></tr>
     *       <tr><td>onTopOnly</td><td><i>boolean</i></td><td>specifies that nothing will be placed between the top dimensions of this item and the top of the box or container it is packed within, overriding <b>maxWeight</b> if previously specified.</td></tr>
     *       <tr><td>packingMaterialThickness</td><td><i>number</i></td><td>FUTURE RELEASE&mdash;a thickness of padding to apply to each face of the fragile item. E.g., a 3"x3"x3" item with 0.5" of <b>packingMaterialThickness</b> will be packed as a 4"x4"x4" volume, as the 0.5" of material will be applied once to each of the top, bottom, front, back, left, and right sides.</td></tr>
     *       <tr><td>priority</td><td><i>number</i></td><td>FUTURE RELEASE&mdash;a priority integer, where higher values will never be placed underneath lower (or unspecified) values.</td></tr>
     *     </table>
     *     <pre>{
     *   "operation": "fragile",
     *   "itemRefId": 0,
     *   "options": {
     *     "display": false,
     *     "onTopOnly": false,
     *     "maxWeight": 5,
     *     "excludeOverweight": true,
     *     "unrestrictedPlacement": true,
     *     "packingMaterialThickness": 0.2,
     *     "priority": 0
     *   }
     * }</pre>
     *   </li>
     *   <li>
     *     <h3>group-pack</h3>
     *     <p>Matching items are to be packed by group based upon the <b>options</b>.</p>
     *     <p><b>"options"</b> contents:</p>
     *        <table>
     *          <tr><th>key</th><th>value</th><th>description</th></tr>
     *          <tr><td>type</td><td>enum</td><td>only 'auto' is currently supported</td></tr>
     *          <tr><td>nameSuffix</td><td>string</td><td>substring to append to all item names in group-pack</td></tr>
     *          <tr><td>scaleFactorThreshold</td><td>number</td><td>only apply axis multiplier to item axes at least 'scaleFactorThreshold' times smaller than the smallest availble 'boxType' dimension on that axis.</td></tr>
     *          <tr><td>axes</td><td>array</td><td>list of axes to potentially scale group-pack dimensions by</td></tr>
     *          <tr><td>axisMultiplier</td><td>int</td><td>for each permitted axis, scale the item dimensions (and the quantity group-packed) by 'axisMultiplier'</td></tr>
     *        </table>
     *     <pre>{
     *   "operation": "group-pack",
     *   "itemMatch": { "all": true },
     *   "options": {
     *     "scaleFactorThreshold": 10,
     *     "axes": [0,1,2],
     *     "axisMultiplier": 8,
     *     "type": "auto",
     *     "nameSuffix": "auto-case-100"
     *   }
     * }</pre>
     *   </li>
     *   <li>
     *     <h3>set-properties</h3>
     *     <p>Set and optionally overwrite any properties on matching items. For example, a shipper who wishes to only ship 1 gallon of nail polish per box can limit all 1-gallon jugs of 50-50 spring water-nail polish solution based upon the weight of its 1/2 (64 oz) nail polish portion. Then, with appropriate box 'propertyConstraints', other items are unrestricted and only nail polish is constrained by its amount.</p>
     *     <p><b>"options"</b> contents:</p>
     *        <table>
     *          <tr><th>key</th><th>value</th><th>description</th></tr>
     *          <tr><td>properties</td><td>object</td><td>an object containing the key-value pairs to set on matching items</td></tr>
     *          <tr><td>overwrite</td><td>boolean</td><td>overwrite properties on items with properties already present (default 'false')</td></tr>
     *        </table>
     *     <pre>{
     *   "operation": "set-properties",
     *   "itemMatch": {
     *     "property": "name",
     *     "expression": "50-50 SPRING WATER-NAIL POLISH SOLUTION, 1.0 GAL",
     *   },
     *   "options": {
     *     "properties": {
     *       "limited-weight-oz": 64.0
     *     }
     *   }
     * }</pre>
     *   </li>
     *   <li>
     *     <h3>pack-sequence</h3>
     *     <p>Set and optionally overwrite any pack sequence value on matching items. Pack sequencing is useful for many purposes, mostly by powering multi-phase packing keyed of item metadata and using helpful reduce functions.</p>
     *     <p><b>"options"</b> contents:</p>
     *        <table>
     *          <tr><th>key</th><th>value</th><th>description</th></tr>
     *          <tr><td>index</td><td>integer</td><td>an object containing the key-value pairs to set on matching items</td></tr>
     *          <tr><td>key</td><td>string</td><td>optional grouping key for separating item groups which must be sequenced at the same step, so their results are combined and processed together. E.g., two item groups are packed separately and in parallel, like (index 0, key "refrigerated") and (index 0, key "room-temperature"), which then both combine on a mixed pallet (index 1) when reduce is set to 'boxes-to-items'</td></tr>
     *          <tr><td>reduce</td><td>enum</td><td>reduce method between steps. enum of 'default' (normal packing, done in strict 'index' order), 'pack-as-is' (boxes are locked after the 'index' step for strict sequence grouping, and 'boxes-to-items' (where boxes are remade as subspaces and then fed-forward as items, for kitting, inner/outer, case->pallet->truck load planning scenarios.)</td></tr>
     *        </table>
     *     <pre>[
     *   {
     *     "operation": "pack-sequence",
     *     "itemMatch": {
     *       "property": "sequence",
     *       "expression": "VAS",
     *     },
     *     "options": {
     *       "index": 0,
     *       "key": "inner-step",
     *       "reduce": "boxes-to-items"
     *     }
     *   },
     *   {
     *     "operation": "pack-sequence",
     *     "itemMatch": {
     *       "all": true
     *     },
     *     "options": {
     *       "index": 1,
     *       "key": "case-step",
     *       "reduce": "boxes-to-items"
     *     }
     *   }
     * ]</pre>
     *   </li>
     * <ul>
     *
     * @enum {string}
     */
    operation:
      | 'exclude'
      | 'exclude-all'
      | 'pack-as-is'
      | 'irregular'
      | 'lock-orientation'
      | 'internal-space'
      | 'alternate-dimensions'
      | 'fragile'
      | 'set-properties'
      | 'group-pack'
      | 'pack-sequence'
    /** @description additional key-value options to pass for rule based on operation type. */
    options?: { [key: string]: unknown }
    /** @description array of supplementary parameters to pass for rule, mostly deprecated. may be different from options. */
    parameters?: string[]
  }
  /**
   * Point
   * @description vector definition used for points, dimensions, and other spacial purposes.
   */
  Point: {
    /**
     * @description x coordinate, used as height.
     * @default 0
     */
    x?: number
    /**
     * @description y coordinate, used as width.
     * @default 0
     */
    y?: number
    /**
     * @description z coordinate, used as length.
     * @default 0
     */
    z?: number
  }
  /** RateTable */
  RateTable: {
    /** @description carrier name for rate table to use */
    carrier?: string
    /** @description service name for rate table to use */
    service?: string
    /** @description zone of rate table to use */
    zone?: string
    /** @description list of prices to use for the weight that corresponds to its index, e.g., [10, 15, 20] would be $10 for 1lb, $15 for 2lbs, $20 for 3lbs. */
    rates?: number[]
    /** @description list of weights to use for the rate that corresponds to its index, e.g., [1, 2, 3] would mean 1lb for the minimum rate ($10), 2lbs for the second rate ($15), and 3lbs for the highest rate ($20). Note that if the highest value from this list is less than the weightMax of the carton, all carton weights exceeding the maximum from this list up to the carton weightMax will not pro-rate but will be estimated at the maximum value in the rate table. */
    weights?: number[]
    /** @description Instead of providing the full rate table, you can list a carton "basePrice" and a carton "priceIncreaseRate". These two values will be used in a simple linear model to guess carton price, i.e., <pre>cartonPrice = priceIncreaseRate * cartonWeight + basePrice</pre> Oftentimes, this will be enough to get accurate carton selections without needing to send complete customer-based rates. It's worth considering, as the prices are only estimates to be used in carton selection, with final rating of cartons happening outside of paccurate. This is the predicted rate of increase for a weight-based pricing model. The simplest way to find a serviceable value is to take <pre>priceIncreaseRate = (maximumPrice - minimumPrice)/(maximumWeight - minimumWeight)</pre> In the example above, this would yield <pre>priceIncreaseRate = ($20-$10)/(3lbs-1lb)<br/>priceIncreaseRate = $10/2lbs<br/>priceIncreaseRate = $5/lb</pre> */
    priceIncreaseRate?: number
    /** @description The basePrice can be found by estimating the lowest weight-based rate available for a given service, in the example above, solving for basePrice for a $10, 1lb package with the already-solved priceIncreaseRate yields <pre>$10 = $5/lb * 1lb + basePrice<br/>$10 = $5 + basePrice<br/>basePrice = $5</pre> */
    basePrice?: number
    /** @description This is the Dimensional Weight divisor. It is given in units of volume per unit weight, e.g., the standard of "139" represents 139 cubic inches per pound, and is used to convert the total volume of a carton into a functional minimum weight to be used when rating the carton. E.g., a carton with dimensions 10" x 10" x 13.9" would yield a volume of 1390 cubic inches. This yields <pre>cartonEffectiveMinimumWeight = 1390in&sup3; / 139in&sup3;/lb<br/>cartonEffectiveMinimumWeight = 10lbs</pre>. To disable when using a preset carrier and zone, set to -1 or a very big number. */
    dimFactor?: number
  }
  /** Subspace */
  Subspace: {
    /** @description the coordinates of the origin of the current subspace translated into its immediate parent. */
    originInParent?: definitions['Point']
    /** @description the index (Box.id) of the subspace's parent box. */
    parentBoxIndex?: number
    /** @description the index (Item.index) of the subspace's parent item, if applicable. */
    parentItemIndex?: number
  }
  /** Image */
  Image: {
    /** @description the index (Box.id) of the box pack the image is a representation of. */
    boxIndex?: number
    /**
     * @description the image format of the data property.
     * @enum {string}
     */
    format?: 'svg' | 'png'
    /** @description base64-encoded image data. */
    data?: string
  }
}

export interface operations {}

export interface external {}
